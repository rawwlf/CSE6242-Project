// Global variables for map
let map;
let routeLayer;
let heatLayer;
let legend;
let lastRouteData;
let lastWeatherData;
let startMarker, endMarker, routeLine;
let startLoc, endLoc;

// Base layers
let lightLayer, darkLayer, streetLayer;
let baseLayers;

// Theme colors
let currentTheme = 'dark'; // Default theme

function getThemeColors() {
    return {
        accent: currentTheme === 'dark' ? '#FFCC00' : '#10B981', // Yellow for dark, Green for light
        // Use yellow shades for congestion levels in dark mode
        low:    currentTheme === 'dark' ? '#FFEB3B' : '#10B981', // Light Yellow for dark, Green for light
        medium: currentTheme === 'dark' ? '#FFC107' : '#059669', // Amber for dark, Dark green for light
        high:   currentTheme === 'dark' ? '#FF9800' : '#047857', // Orange for dark, Darker green for light
        severe: currentTheme === 'dark' ? '#FF5722' : '#065F46', // Deep Orange for dark, Deepest green for light
        background: currentTheme === 'dark' ? '#1e1e1e' : '#FFFFFF',
        text: currentTheme === 'dark' ? '#FFFFFF' : '#333333'
    };
}

// Initialize map with center at New York
function initMap() {
    // Initialize route layer
    routeLayer = L.layerGroup();
    
    // Create map
    map = L.map('map').setView([40.7128, -74.0060], 12);

    // Base maps for different themes
    lightLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        maxZoom: 19
    });

    darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        maxZoom: 19
    });

    streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19
    });

    // Set up base layers for control
    baseLayers = {
        "Light": lightLayer,
        "Dark": darkLayer,
        "Street": streetLayer
    };

    // Initialize with theme based on user preference
    applyTheme();

    // Add route layer to map
    routeLayer.addTo(map);

    // Remove layer control to simplify UI
    // Only add control for base layers (not route layer)
    L.control.layers(baseLayers).addTo(map);
}

// Apply theme to map and UI
function applyTheme() {
    document.documentElement.className = currentTheme + '-mode';
    updateMapBaseLayer();
    
    // Update legend if it exists
    if (map && legend) {
        updateMapLegend();
    }
    
    // Update route display if exists
    if (lastRouteData && lastWeatherData) {
        displayRoute(lastRouteData, lastWeatherData);
    }
    
    // Update heatmap if it exists
    if (heatLayer && map.hasLayer(heatLayer)) {
        // Remove existing heatmap
        map.removeLayer(heatLayer);
        // Recreate with new theme colors
        if (lastRouteData) {
            createHeatmapLayer(lastRouteData);
        }
    }
}

// Toggle between light and dark themes
function toggleTheme() {
    const html = document.documentElement;
    if (html.classList.contains('light-mode')) {
        // Switch to dark mode
        html.classList.remove('light-mode');
        localStorage.setItem('theme', 'dark');
        currentTheme = 'dark';
        updateMapBaseLayer('dark');
    } else {
        // Switch to light mode
        html.classList.add('light-mode');
        localStorage.setItem('theme', 'light');
        currentTheme = 'light';
        updateMapBaseLayer('light');
    }
    
    // Update UI with new theme colors
    applyTheme();
}

// Function to update map base layer based on current theme
function updateMapBaseLayer(theme) {
    if (theme === 'light') {
        if (map.hasLayer(darkLayer)) map.removeLayer(darkLayer);
        if (!map.hasLayer(lightLayer)) map.addLayer(lightLayer);
    } else {
        if (map.hasLayer(lightLayer)) map.removeLayer(lightLayer);
        if (!map.hasLayer(darkLayer)) map.addLayer(darkLayer);
    }
}

// Initialize theme based on user preference or local storage
function initializeTheme() {
    const savedTheme = localStorage.getItem('theme');
    const prefersDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (savedTheme === 'light' || (!savedTheme && !prefersDarkMode)) {
        document.documentElement.classList.add('light-mode');
        currentTheme = 'light';
        updateMapBaseLayer('light');
    } else {
        document.documentElement.classList.remove('light-mode');
        currentTheme = 'dark';
        updateMapBaseLayer('dark');
    }
}

// Update map legend with current theme colors
function updateMapLegend() {
    // Legend removed as per user request
    if (legend) {
        map.removeControl(legend);
        legend = null;
    }
}

// Set default date to today
function setDefaultDate() {
    const today = new Date();
    const formattedDate = today.toISOString().slice(0, 10);
    const dateSelect = document.getElementById('date-select');
    if (dateSelect) {
        dateSelect.value = formattedDate;
    }
}

// Initialize the app when the document is loaded
document.addEventListener('DOMContentLoaded', function() {
    initMap();
    setDefaultDate();
    initializeTheme();
    
    // Add event listener for calculate route button
    const calculateRouteBtn = document.getElementById('calculate-route');
    if (calculateRouteBtn) {
        calculateRouteBtn.addEventListener('click', calculateRoute);
    }

    // Add event listener for theme toggle button
    const themeToggleBtn = document.getElementById('theme-toggle');
    if (themeToggleBtn) {
        themeToggleBtn.addEventListener('click', toggleTheme);
    }
});

// API calls and route calculation
function calculateRoute() {
    const start = document.getElementById('start-input').value;
    const end = document.getElementById('end-input').value;
    const date = document.getElementById('date-select').value;
    const time = document.getElementById('time-select').value;
    
    if (!start || !end) {
        alert('Please enter both start and end locations');
        return;
    }
    
    // Show loading indicator if it exists
    const loadingEl = document.getElementById('loading');
    if (loadingEl) loadingEl.style.display = 'block';
    
    // Clear previous route
    routeLayer.clearLayers();
    if (heatLayer && map.hasLayer(heatLayer)) {
        map.removeLayer(heatLayer);
        heatLayer = null;
    }
    
    // Make API request to route endpoint (using POST method)
    fetch('/api/route', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            start: start,
            end: end,
            date: date,
            time: time
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(err.error || `Route API error: ${response.status}`);
            });
        }
        return response.json();
    })
    .then(data => {
        if (!data.success) {
            throw new Error(data.error || 'Failed to calculate route');
        }
        
        // Save data for theme switching
        lastRouteData = data.route;
        
        // Get weather data
        return fetch('/api/weather')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Weather API error: ${response.status}`);
                }
                return response.json();
            })
            .then(weatherData => {
                lastWeatherData = weatherData;
                // Display route with weather data
                if (data.route && data.success) {
                    displayRoute(data.route, weatherData);
                }
            });
    })
    .catch(error => {
        console.error('Error fetching data:', error);
        
        // Show error message if error element exists
        const errorMessage = document.getElementById('error-message');
        if (errorMessage) {
            errorMessage.textContent = error.message || 'Failed to calculate route. Please try again.';
            errorMessage.style.display = 'block';
            
            // Hide after 5 seconds
            setTimeout(() => {
                errorMessage.style.display = 'none';
            }, 5000);
        } else {
            // Fallback to alert if no error element
            alert(error.message || 'Failed to calculate route. Please try again.');
        }
    })
    .finally(() => {
        // Hide loading indicator
        if (loadingEl) loadingEl.style.display = 'none';
    });
}

// Display route on map
function displayRoute(routeData, weatherData) {
    // Clear existing route
    routeLayer.clearLayers();
    if (heatLayer && map.hasLayer(heatLayer)) {
        map.removeLayer(heatLayer);
        heatLayer = null;
    }
    
    if (startMarker) map.removeLayer(startMarker);
    if (endMarker) map.removeLayer(endMarker);
    if (routeLine) map.removeLayer(routeLine);
    
    // Extract route coordinates and congestion levels
    const route_coords = routeData.route_coords || [];
    
    if (route_coords.length === 0) {
        console.error("No route coordinates found in data");
        return;
    }
    
    // For congestion data, we'll use edge data if available
    const edges = routeData.edges || [];
    let congestionData = [];
    
    if (edges.length > 0) {
        // Extract congestion levels from edges
        congestionData = edges.map(edge => edge.congestion_level || 0.5);
    }
    
    // Create start and end markers
    const colors = getThemeColors();
    
    // Custom pin marker for start location (consistent pin style)
    const startIcon = L.divIcon({
        className: 'custom-marker start-marker',
        html: `<div style="width: 30px; height: 40px; position: relative;">
                 <div style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); 
                      width: 20px; height: 20px; border-radius: 50%; background-color: ${colors.accent}; 
                      border: 2px solid #FFFFFF;"></div>
                 <div style="position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%) rotate(45deg); 
                      width: 15px; height: 15px; background-color: ${colors.accent}; 
                      border: 2px solid #FFFFFF; border-bottom: none; border-right: none;"></div>
               </div>`,
        iconSize: [30, 40],
        iconAnchor: [15, 40]
    });
    
    // Custom pin marker for end location (consistent pin style)
    const endIcon = L.divIcon({
        className: 'custom-marker end-marker',
        html: `<div style="width: 30px; height: 40px; position: relative;">
                 <div style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); 
                      width: 20px; height: 20px; border-radius: 50%; background-color: ${colors.accent}; 
                      border: 2px solid #FFFFFF;"></div>
                 <div style="position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%) rotate(45deg); 
                      width: 15px; height: 15px; background-color: ${colors.accent}; 
                      border: 2px solid #FFFFFF; border-bottom: none; border-right: none;"></div>
               </div>`,
        iconSize: [30, 40],
        iconAnchor: [15, 40] // Adjusted anchor for pin style
    });
    
    // Add markers to the route layer
    startMarker = L.marker(route_coords[0], { icon: startIcon }).addTo(map);
    endMarker = L.marker(route_coords[route_coords.length - 1], { icon: endIcon }).addTo(map);
    routeLayer.addLayer(startMarker);
    routeLayer.addLayer(endMarker);
    
    // Create polyline for route
    routeLine = L.polyline(route_coords, {
        color: colors.accent,
        weight: 5,
        opacity: 0.7
    }).addTo(map);
    routeLayer.addLayer(routeLine);
    
    // Create heatmap representation of congestion
    if (edges.length > 0) {
        // Use the edge start and end points for a more detailed heatmap
        const heatPoints = [];
        
        edges.forEach(edge => {
            // The intensity is the congestion level (0-1 scale)
            const intensity = edge.congestion_level || 0.5;
            
            // Add points for the start and end of each edge
            heatPoints.push([edge.start[0], edge.start[1], intensity * 2]);
            heatPoints.push([edge.end[0], edge.end[1], intensity * 2]);
        });
        
        heatLayer = L.heatLayer(heatPoints, {
            radius: 25,
            blur: 15,
            maxZoom: 17,
            gradient: {
                0.2: colors.low,
                0.5: colors.medium,
                0.7: colors.high,
                0.9: colors.severe
            }
        }).addTo(map);
    }
    
    // Zoom to fit the route
    map.fitBounds(routeLine.getBounds(), {
        padding: [50, 50]
    });
    
    // Update route information panel
    updateRouteInfo(routeData, weatherData);
    
    // Show route info
    const routeInfo = document.getElementById('route-info');
    if (routeInfo) routeInfo.style.display = 'block';
}

// Create heatmap data points along the route
function createHeatmapData(points, congestion) {
    // Interpolate points along the route to create a smoother heatmap effect
    const heatPoints = [];
    const numPoints = points.length;
    
    // Use congestion values as intensities for the heatmap
    for (let i = 0; i < numPoints; i++) {
        const intensity = congestion[i] || 0.5; // Default intensity if not provided
        heatPoints.push([
            points[i][0],
            points[i][1],
            intensity * 2 // Multiply by 2 to make low congestion levels more visible
        ]);
        
        // Add interpolated points if not at the last point
        if (i < numPoints - 1) {
            const p1 = points[i];
            const p2 = points[i + 1];
            const c1 = congestion[i] || 0.5;
            const c2 = congestion[i + 1] || 0.5;
            
            // Add 3 interpolated points between each pair of actual points
            for (let j = 1; j <= 3; j++) {
                const ratio = j / 4;
                const lat = p1[0] + (p2[0] - p1[0]) * ratio;
                const lng = p1[1] + (p2[1] - p1[1]) * ratio;
                const interIntensity = c1 + (c2 - c1) * ratio;
                
                heatPoints.push([lat, lng, interIntensity * 2]);
            }
        }
    }
    
    return heatPoints;
}

// Update the route information panel
function updateRouteInfo(routeData, weatherData) {
    // Update distance
    const distanceEl = document.getElementById('distance');
    if (distanceEl) {
        distanceEl.textContent = routeData.distance_miles ? routeData.distance_miles + ' mi' : '-';
    }
    
    // Update duration
    const durationEl = document.getElementById('duration');
    if (durationEl) {
        durationEl.textContent = routeData.estimated_travel_time ? 
            routeData.estimated_travel_time + ' min' : '-';
    }
    
    // Update congestion delay
    const delayEl = document.getElementById('congestion-delay');
    if (delayEl) {
        delayEl.textContent = routeData.congestion_delay ? 
            '+ ' + routeData.congestion_delay + ' min' : '-';
    }
    
    // Update base duration (without congestion)
    const baseDurationEl = document.getElementById('base-duration');
    if (baseDurationEl) {
        baseDurationEl.textContent = routeData.base_travel_time ? 
            routeData.base_travel_time + ' min' : '-';
    }
    
    // Update weather condition
    const weatherEl = document.getElementById('weather-condition');
    if (weatherEl && weatherData && weatherData.success && weatherData.weather) {
        weatherEl.textContent = weatherData.weather.Weather_Conditions || 'Unknown';
    }
}

// Update weather information in the panel
function updateWeatherInfo(weatherData) {
    const weatherInfo = document.getElementById('weather-info');
    
    if (weatherData && weatherData.current) {
        const current = weatherData.current;
        
        // Create weather info HTML
        let html = `
            <div class="weather-condition">
                <i class="fas ${getWeatherIcon(current.condition)}"></i>
                <span>${current.condition}</span>
            </div>
            <div class="weather-temp">${Math.round(current.temperature)}°F</div>
            <div class="weather-details">
                <div><i class="fas fa-tint"></i> ${current.precipitation}%</div>
                <div><i class="fas fa-wind"></i> ${current.wind_speed} mph</div>
            </div>
        `;
        
        weatherInfo.innerHTML = html;
        weatherInfo.style.display = 'block';
    } else {
        weatherInfo.style.display = 'none';
    }
}

// Format distance in miles
function formatDistance(meters) {
    const miles = meters / 1609.34;
    return miles.toFixed(1) + ' mi';
}

// Format duration in minutes/hours
function formatDuration(seconds) {
    if (seconds < 60) {
        return seconds + ' sec';
    } else if (seconds < 3600) {
        return Math.floor(seconds / 60) + ' min';
    } else {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return hours + ' hr ' + (minutes > 0 ? minutes + ' min' : '');
    }
}

// Get congestion level description
function getCongestionLevel(value) {
    if (value < 0.3) return 'Low';
    if (value < 0.6) return 'Medium';
    if (value < 0.8) return 'High';
    return 'Severe';
}

// Get appropriate weather icon
function getWeatherIcon(condition) {
    condition = condition.toLowerCase();
    
    if (condition.includes('rain') || condition.includes('shower')) {
        return 'fa-cloud-rain';
    } else if (condition.includes('snow')) {
        return 'fa-snowflake';
    } else if (condition.includes('thunderstorm')) {
        return 'fa-bolt';
    } else if (condition.includes('fog') || condition.includes('mist')) {
        return 'fa-smog';
    } else if (condition.includes('cloud')) {
        return 'fa-cloud';
    } else if (condition.includes('clear') || condition.includes('sunny')) {
        return 'fa-sun';
    } else {
        return 'fa-cloud';
    }
}

// Event listener for theme changes
window.addEventListener('themechange', function() {
    const isDarkMode = !document.documentElement.classList.contains('light-mode');
    
    // Update map base layer
    updateMapTheme(isDarkMode);
    
    // Refresh heatmap and route if they exist
    if (lastRouteData) {
        displayRoute(lastRouteData, lastWeatherData);
    }
});

function updateMapTheme(isDarkMode) {
    // Remove all current base layers
    if (map.hasLayer(lightLayer)) map.removeLayer(lightLayer);
    if (map.hasLayer(darkLayer)) map.removeLayer(darkLayer);
    if (map.hasLayer(streetLayer)) map.removeLayer(streetLayer);
    
    // Add appropriate base layer based on theme
    if (isDarkMode) {
        darkLayer.addTo(map);
    } else {
        lightLayer.addTo(map);
    }
}
